const opts={seperator:".",comma:",",equal:"=",arrayMap:"*",pipe:"|",invoke:"&"},fmtr={},dig=function(t,e,i=opts,o=fmtr){if(!t||!e)return null;if("object"==typeof e){if(Array.isArray(e))return e.map(e=>dig(t,e,i,o));const n=Object.keys(e),s={};for(const f of n)s[f]=dig(t,e[f],i,o);return s}let n=t,s=e.split(i.seperator);for(let e=0;e<s.length;e+=1){const f=s[e];if(-1!==f.indexOf(i.pipe)){const t=f.split(i.pipe);let e=null;for(const s of t)if(e=dig(n,s,i,o))break;n=e}else if(-1!==f.indexOf(i.comma)){const t=f.split(i.comma),e={};for(const s of t)e[s]=dig(n,s,i,o);n=e}else if(-1!==f.indexOf(i.equal)){const t=f.split(i.equal),e=t[0],o=t[1];n=n.find(t=>e?t[e]==o:t==o)}else if(f===i.arrayMap)e+=1,n=n.map(t=>dig(t,s.slice(e)[0],i,o));else if(-1!==f.indexOf(i.invoke)){const e=f.split(i.invoke);let s=dig(n,e.shift(),i,o);for(const i of e)"function"==typeof o[i]&&(s=o[i](s,t));n=s}else n=n[f];if(null==n||null==n)return null}return n},output={dig:dig,setFormatter:function(t){Object.assign(fmtr,t)},setOptions:function(t){Object.assign(opts,t)}};"undefined"!=typeof window&&Object.assign(window,output),"undefined"!=typeof process&&(module.exports=output);